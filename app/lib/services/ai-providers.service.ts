/**
 * AI Provider Service
 * Handles integration with FAL AI and Replicate for image generation pipeline
 */

import { fal } from "@fal-ai/client";
import Replicate from "replicate";
import {
  uploadToShopifyGenerationsBucket,
  downloadImageAsBuffer,
  generateUniqueFileName,
  type UploadResult,
} from "./storage.service";

// =============================================
// TYPES
// =============================================

export interface TryOnResult {
  image_url: string;
  seed?: number;
  has_nsfw_concepts?: boolean;
}

export interface UpscaleResult {
  image_url: string;
}

export interface FaceSwapResult {
  output: string; // Replicate returns single URL
}

export type QualityLevel = 'standard' | 'high' | 'premium';
export type PipelineStep = 'tryon' | 'basic-upscale' | 'enhanced-upscale' | 'replicate-face-swap';

// =============================================
// CONFIGURATION
// =============================================

const FAL_API_KEY = process.env.FAL_KEY;
const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;

// Initialize FAL AI client
if (!FAL_API_KEY) {
  console.error('âŒ CRITICAL: FAL_KEY environment variable is not set!');
  console.error('Please check your .env file in the trayve-app directory');
} else {
  // Log the key format (first 10 chars only for security)
  const keyPreview = FAL_API_KEY.substring(0, 10) + '...';
  console.log('ğŸ”‘ FAL_KEY found:', keyPreview);
  console.log('ğŸ”‘ FAL_KEY length:', FAL_API_KEY.length);
  console.log('ğŸ”‘ FAL_KEY format check:', FAL_API_KEY.includes(':') ? 'Contains colon âœ“' : 'Missing colon âœ—');
  
  // Configure FAL client with credentials
  fal.config({
    credentials: FAL_API_KEY,
  });
  console.log('âœ… FAL AI client configured');
}

// Initialize Replicate client
let replicate: Replicate | null = null;
if (!REPLICATE_API_TOKEN) {
  console.warn('âš ï¸  REPLICATE_API_TOKEN environment variable is not set');
} else {
  replicate = new Replicate({
    auth: REPLICATE_API_TOKEN,
  });
  console.log('âœ… Replicate client configured');
}

// =============================================
// FAL AI CLIENT
// =============================================

/**
 * Execute try-on generation using FAL AI Fashion Try-On
 * @param modelImageUrl - URL of the model/pose image
 * @param clothingImageUrl - URL of the clothing item
 * @param quality - Quality level for generation
 */
export async function executeTryOn(
  modelImageUrl: string,
  clothingImageUrl: string,
  quality: QualityLevel = 'standard',
  gender: 'male' | 'female' = 'female'
): Promise<TryOnResult> {
  if (!FAL_API_KEY) {
    throw new Error('FAL AI API key is not configured');
  }

  try {
    console.log('ğŸ¨ Starting try-on generation with FAL AI Fashion Try-On...', {
      model: modelImageUrl.substring(0, 80) + '...',
      clothing: clothingImageUrl.substring(0, 80) + '...',
      quality,
      gender,
    });

    // Use Fashion Try-On model for virtual try-on (easel-ai/fashion-tryon)
    // Configuration:
    // - full_body_image: URL of the model/person image
    // - clothing_image: URL of the clothing/garment image
    // - gender: 'male' or 'female' (defaults to 'female')
    const result = await fal.subscribe('easel-ai/fashion-tryon', {
      input: {
        full_body_image: modelImageUrl as any,
        clothing_image: clothingImageUrl as any,
        gender: gender as any,
      },
      logs: true,
      onQueueUpdate: (update: any) => {
        if (update.status === 'IN_PROGRESS') {
          console.log(`ğŸ’« Try-on generation progress: ${update.status}`);
        }
      },
    });

    console.log('âœ… Try-on generation completed successfully');

    // Extract image URL from result
    const imageUrl = result.data?.image?.url;
    
    if (!imageUrl) {
      console.error('âŒ No image URL in result:', result);
      throw new Error('No image generated by FAL AI Fashion Try-On');
    }

    console.log('ğŸ“¸ Generated image URL:', imageUrl.substring(0, 100) + '...');

    return {
      image_url: imageUrl,
      has_nsfw_concepts: false,
    };
  } catch (error) {
    console.error('âŒ FAL AI try-on error:', error);
    
    // Log detailed error information for debugging
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log validation errors from FAL AI
    if ((error as any).body?.detail) {
      console.error('ğŸ” Validation details:', JSON.stringify((error as any).body.detail, null, 2));
    }
    
    throw error;
  }
}

/**
 * Execute basic upscale using Replicate CodeFormer
 * @param imageUrl - URL of the image to upscale
 */
export async function executeBasicUpscale(imageUrl: string): Promise<UpscaleResult> {
  if (!REPLICATE_API_TOKEN) {
    throw new Error('Replicate API token is not configured');
  }

  try {
    console.log('ğŸ“ˆ Starting basic upscale (2K) with Replicate CodeFormer...');
    console.log('ğŸ–¼ï¸  Input image:', imageUrl.substring(0, 100) + '...');
    
    const startTime = Date.now();

    // Use CodeFormer for face upsampling and enhancement (Replicate)
    // Configuration for ALL tiers (Free, Starter, Professional, Enterprise)
    const version = "cc4956dd26fa5a7185d5660cc9100fab1b8070a1d1654a8bb5eb6d443b020bb2";
    
    const response = await fetch("https://api.replicate.com/v1/predictions", {
      method: "POST",
      headers: {
        "Authorization": `Token ${REPLICATE_API_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        version,
        input: {
          image: imageUrl,
          codeformer_fidelity: 0.1,  // CodeFormer fidelity weight
          background_enhance: false,
          face_upsample: false,
          upscale: 1,                 // Upscaling factor (no upscaling, just enhancement)
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Replicate API error: ${response.status} ${response.statusText}`);
    }

    let prediction = await response.json();
    const predictionId = prediction.id;
    
    console.log(`ğŸ”„ Basic upscale queued, prediction ID: ${predictionId}`);

    // Poll for completion
    while (prediction.status === 'starting' || prediction.status === 'processing') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const statusResponse = await fetch(`https://api.replicate.com/v1/predictions/${predictionId}`, {
        headers: {
          "Authorization": `Token ${REPLICATE_API_TOKEN}`,
        },
      });
      
      prediction = await statusResponse.json();
      
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(`â³ Basic upscale in progress... (${elapsed}s elapsed, status: ${prediction.status})`);
    }

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    
    if (prediction.status !== 'succeeded') {
      throw new Error(`CodeFormer prediction failed with status: ${prediction.status}`);
    }

    console.log(`âœ… Basic upscale completed in ${totalTime}s`);

    // Extract image URL from result
    const upscaledUrl = prediction.output;
    
    if (!upscaledUrl) {
      console.error('âŒ No upscaled image in response:', JSON.stringify(prediction, null, 2));
      throw new Error('No upscaled image generated by Replicate CodeFormer');
    }

    console.log('ğŸ“¸ Upscaled image URL:', upscaledUrl.substring(0, 100) + '...');

    return {
      image_url: upscaledUrl,
    };
  } catch (error) {
    console.error('âŒ Replicate CodeFormer basic upscale error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    throw error;
  }
}

/**
 * Execute enhanced upscale using FAL AI Recraft V3 Creative Upscaler
 * @param imageUrl - URL of the image to upscale
 */
export async function executeEnhancedUpscale(imageUrl: string): Promise<UpscaleResult> {
  if (!FAL_API_KEY) {
    throw new Error('FAL AI API key is not configured');
  }

  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ” ENHANCED UPSCALE (4K) - START');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ“· Input image URL:', imageUrl.substring(0, 100) + '...');
  console.log('ğŸ¤– Model: FAL AI Recraft V3 Creative Upscale');
  console.log('ğŸ“ Upscaling: Creative enhancement');

  try {
    const startTime = Date.now();

    // Use Recraft V3 Creative Upscaler for 4K enhancement
    const result = await fal.subscribe('fal-ai/recraft/upscale/creative', {
      input: {
        image_url: imageUrl,
        sync_mode: true,
        enable_safety_checker: false,
      },
      logs: true,
      onQueueUpdate: (update: any) => {
        if (update.status === 'IN_PROGRESS') {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          console.log(`â³ Enhanced upscale in progress... (${elapsed}s elapsed)`);
        } else if (update.status === 'IN_QUEUE') {
          console.log(`ğŸ”„ Enhanced upscale queued, position: ${update.queue_position || 'unknown'}`);
        }
      },
    });

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`âœ… Enhanced upscale processing completed in ${totalTime}s`);

    // Extract image URL from result
    const upscaledUrl = result.data?.image?.url;
    
    if (!upscaledUrl) {
      console.error('âŒ No upscaled image in response:', JSON.stringify(result.data, null, 2));
      throw new Error('No enhanced upscaled image generated by FAL AI Recraft V3');
    }

    console.log('ğŸ“¸ Enhanced upscaled image URL:', upscaledUrl.substring(0, 100) + '...');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âœ… ENHANCED UPSCALE (4K) - COMPLETE');
    console.log(`â±ï¸  Total time: ${totalTime}s`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    return {
      image_url: upscaledUrl,
    };
  } catch (error) {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âŒ ENHANCED UPSCALE (4K) - FAILED');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('âŒ FAL AI enhanced upscale error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log FAL AI specific errors
    if ((error as any).body) {
      console.error('FAL AI error body:', JSON.stringify((error as any).body, null, 2));
    }
    
    if ((error as any).status) {
      console.error('FAL AI error status:', (error as any).status);
    }
    
    throw error;
  }
}

// =============================================
// REPLICATE CLIENT
// =============================================

/**
 * Execute face swap using Replicate Trayve Custom Model
 * @param sourceImageUrl - URL of the model image (face to extract FROM)
 * @param targetImageUrl - URL of the generated image (apply face TO)
 */
export async function executeFaceSwap(
  sourceImageUrl: string,
  targetImageUrl: string
): Promise<FaceSwapResult> {
  if (!replicate) {
    throw new Error('Replicate API token is not configured');
  }

  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ‘¤ FACE SWAP - START');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('ğŸ“¸ Source image (face FROM):', sourceImageUrl.substring(0, 80) + '...');
  console.log('ğŸ¯ Target image (apply TO):', targetImageUrl.substring(0, 80) + '...');
  console.log('ğŸ¤– Model: Replicate Trayve Custom Model');

  try {
    const startTime = Date.now();

    // Use Trayve custom face swap model (matches working main app)
    // Model: trayve-us/swap-model with specific version hash
    const modelVersion = "trayve-us/swap-model:7c647d4895ea2d5ff80ff3374709e3b35fa6ae070920f2ecf5d0c118b1a4a0f2";
    console.log('ğŸš€ Submitting to Replicate API...');
    console.log('â³ Face swap processing started...');
    
    // Create prediction and poll for updates
    const prediction = await replicate.predictions.create({
      version: modelVersion.split(':')[1],
      input: {
        source_image: sourceImageUrl,  // Face to extract FROM
        target_image: targetImageUrl,  // Image to apply face TO
      }
    });
    
    console.log(`ğŸ“‹ Prediction ID: ${prediction.id}`);
    console.log(`ğŸ“Š Initial status: ${prediction.status}`);
    
    // Poll for completion with progress updates
    let currentPrediction = prediction;
    let lastLogTime = Date.now();
    
    while (currentPrediction.status !== 'succeeded' && currentPrediction.status !== 'failed' && currentPrediction.status !== 'canceled') {
      await new Promise(resolve => setTimeout(resolve, 1000)); // Poll every second
      
      currentPrediction = await replicate.predictions.get(prediction.id);
      
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      
      // Log progress every 5 seconds
      if (Date.now() - lastLogTime > 5000) {
        console.log(`â³ Face swap in progress... (${elapsed}s elapsed, status: ${currentPrediction.status})`);
        lastLogTime = Date.now();
      }
    }
    
    if (currentPrediction.status === 'failed') {
      const errorMsg = typeof currentPrediction.error === 'string' ? currentPrediction.error : 'Face swap failed';
      throw new Error(errorMsg);
    }
    
    if (currentPrediction.status === 'canceled') {
      throw new Error('Face swap was canceled');
    }
    
    const output = currentPrediction.output;
    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`âœ… Face swap processing completed in ${totalTime}s`);
    console.log(`ğŸ” Output type: ${typeof output}`);
    console.log(`ğŸ” Output value:`, output);

    // Handle multiple output formats from Replicate
    let resultUrl: string;
    
    if (typeof output === 'string') {
      // Direct string URL (expected format)
      resultUrl = output;
      console.log('âœ… Output is direct string URL');
    } else if (Array.isArray(output) && output.length > 0) {
      // Array of URLs - take first one
      resultUrl = output[0];
      console.log(`âœ… Output is array, using first element: ${resultUrl.substring(0, 80)}...`);
    } else if (output && typeof output === 'object') {
      // Object with url property or ReadableStream
      if ('url' in output && typeof (output as any).url === 'string') {
        resultUrl = (output as any).url;
        console.log(`âœ… Extracted URL from object.url property`);
      } else {
        // ReadableStream or other object - convert to string and hope for URL
        console.warn('âš ï¸  Unexpected output format, attempting string conversion');
        resultUrl = String(output);
      }
    } else {
      console.error('âŒ Invalid face swap output type:', typeof output);
      console.error('âŒ Output value:', output);
      throw new Error(`Unexpected output format from Replicate: ${typeof output}`);
    }

    // Validate the result is a valid URL string
    if (!resultUrl || typeof resultUrl !== 'string' || resultUrl.length === 0) {
      console.error('âŒ Result URL is empty or invalid:', resultUrl);
      throw new Error('Face swap did not return a valid image URL');
    }

    console.log('ğŸ“¸ Face swap result URL:', resultUrl.substring(0, 100) + '...');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âœ… FACE SWAP - COMPLETE');
    console.log(`â±ï¸  Total time: ${totalTime}s`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    return {
      output: resultUrl,
    };
  } catch (error) {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('âŒ FACE SWAP - FAILED');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('âŒ Replicate face swap error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log Replicate specific errors
    if ((error as any).response) {
      console.error('Replicate error response:', JSON.stringify((error as any).response, null, 2));
    }
    
    if ((error as any).status) {
      console.error('Replicate error status:', (error as any).status);
    }
    
    throw error;
  }
}

// =============================================
// TIER-BASED STEP CONFIGURATION
// =============================================

/**
 * Get enabled steps for a subscription tier
 */
export function getEnabledSteps(tier: string): PipelineStep[] {
  const tierSteps: Record<string, PipelineStep[]> = {
    free: ['tryon', 'basic-upscale'],
    creator: ['tryon', 'basic-upscale'],
    professional: ['tryon', 'basic-upscale', 'enhanced-upscale', 'replicate-face-swap'],
    enterprise: ['tryon', 'basic-upscale', 'enhanced-upscale', 'replicate-face-swap'],
  };

  return tierSteps[tier] || tierSteps.free;
}

/**
 * Get quality level for a subscription tier
 */
export function getQualityLevel(tier: string): QualityLevel {
  const tierQuality: Record<string, QualityLevel> = {
    free: 'standard',
    creator: 'high',
    professional: 'premium',
    enterprise: 'premium',
  };

  return tierQuality[tier] || 'standard';
}

// =============================================
// PIPELINE EXECUTOR
// =============================================

export interface PipelineConfig {
  tier: string;
  enabledSteps?: PipelineStep[];
  quality?: QualityLevel;
  gender?: 'male' | 'female';
  onStepComplete?: (step: PipelineStepResult) => Promise<void>;  // NEW: Callback for incremental updates
}

export interface PipelineStepResult {
  stepType: PipelineStep;
  status: 'completed' | 'failed' | 'skipped';
  imageUrl?: string;  // Final stored URL (Supabase)
  originalUrl?: string;  // Original FAL.AI/Replicate URL (for next steps, bypasses 5MB limit)
  error?: string;
  processingTime?: number;
}

// =============================================
// HELPER FUNCTIONS
// =============================================

/**
 * Upload step image to Supabase storage
 * Downloads image from AI provider URL and uploads to Supabase
 * @param aiProviderUrl - URL from FAL/Replicate
 * @param stepType - Pipeline step type
 * @param executionId - Unique execution ID
 * @returns Supabase public URL
 */
async function uploadStepImageToSupabase(
  aiProviderUrl: string,
  stepType: PipelineStep,
  executionId: string
): Promise<string> {
  try {
    console.log(`ğŸ“¤ Uploading ${stepType} image to Supabase...`);
    console.log(`   AI Provider URL: ${aiProviderUrl.substring(0, 80)}...`);
    
    // Download image from AI provider
    const imageBuffer = await downloadImageAsBuffer(aiProviderUrl);
    console.log(`âœ… Downloaded image: ${imageBuffer.length} bytes`);
    
    // Generate unique filename
    const fileName = generateUniqueFileName('png', `${executionId}/${stepType}`);
    
    // Upload to Supabase
    const uploadResult = await uploadToShopifyGenerationsBucket(
      imageBuffer,
      fileName,
      'image/png'
    );
    
    console.log(`âœ… Uploaded to Supabase: ${uploadResult.url.substring(0, 80)}...`);
    return uploadResult.url;
  } catch (error) {
    console.error(`âŒ Failed to upload ${stepType} image to Supabase:`, error);
    // Fall back to AI provider URL if upload fails
    return aiProviderUrl;
  }
}

// =============================================
// PIPELINE EXECUTION
// =============================================

/**
 * Execute full pipeline with tier-based steps
 * @param modelImageUrl - URL of the model/pose image
 * @param clothingImageUrl - URL of the clothing item
 * @param config - Pipeline configuration
 * @param executionId - Unique execution ID for storage path
 */
export async function executePipeline(
  modelImageUrl: string,
  clothingImageUrl: string,
  config: PipelineConfig,
  executionId: string
): Promise<PipelineStepResult[]> {
  const enabledSteps = config.enabledSteps || getEnabledSteps(config.tier);
  const quality = config.quality || getQualityLevel(config.tier);
  const gender = config.gender || 'female';
  
  const results: PipelineStepResult[] = [];
  let currentImageUrl = '';

  console.log('ğŸš€ Starting pipeline execution...', {
    tier: config.tier,
    steps: enabledSteps,
    quality,
    gender,
  });

  // Step 1: Try-On (Required)
  if (enabledSteps.includes('tryon')) {
    const startTime = Date.now();
    try {
      const tryOnResult = await executeTryOn(modelImageUrl, clothingImageUrl, quality, gender);
      const aiProviderUrl = tryOnResult.image_url;
      
      // Upload to Supabase immediately
      const supabaseUrl = await uploadStepImageToSupabase(aiProviderUrl, 'tryon', executionId);
      currentImageUrl = aiProviderUrl;  // Use AI provider URL for next step (bypasses 5MB limit)
      
      const stepResult: PipelineStepResult = {
        stepType: 'tryon',
        status: 'completed',
        imageUrl: supabaseUrl,  // Store Supabase URL in metadata
        originalUrl: aiProviderUrl,  // Keep AI provider URL for next step
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for real-time update
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
    } catch (error) {
      const stepResult: PipelineStepResult = {
        stepType: 'tryon',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback even for failures
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
      
      // If try-on fails, entire pipeline fails
      throw error;
    }
  }

  // Step 2: Basic Upscale
  if (enabledSteps.includes('basic-upscale') && currentImageUrl) {
    const startTime = Date.now();
    try {
      const upscaleResult = await executeBasicUpscale(currentImageUrl);
      const aiProviderUrl = upscaleResult.image_url;  // Replicate URL
      
      // Upload to Supabase immediately
      const supabaseUrl = await uploadStepImageToSupabase(aiProviderUrl, 'basic-upscale', executionId);
      currentImageUrl = aiProviderUrl;  // Use AI provider URL for next step
      
      const stepResult: PipelineStepResult = {
        stepType: 'basic-upscale',
        status: 'completed',
        imageUrl: supabaseUrl,  // Store Supabase URL in metadata
        originalUrl: aiProviderUrl,  // Keep Replicate URL for next step
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for real-time update (2K is ready!)
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
    } catch (error) {
      console.warn('âš ï¸  Basic upscale failed, continuing with original image:', error);
      const stepResult: PipelineStepResult = {
        stepType: 'basic-upscale',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for failures too
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
      // Continue with previous image
    }
  }

  // Step 3: Enhanced Upscale (Professional/Enterprise only)
  if (enabledSteps.includes('enhanced-upscale') && currentImageUrl) {
    const startTime = Date.now();
    try {
      // Use originalUrl from previous step to bypass 5MB limit
      const previousStep = results[results.length - 1];
      const inputUrl = previousStep?.originalUrl || currentImageUrl;
      
      console.log(`ğŸ“¥ Enhanced upscale input: ${inputUrl.substring(0, 80)}...`);
      const enhancedResult = await executeEnhancedUpscale(inputUrl);
      const aiProviderUrl = enhancedResult.image_url;
      
      // Upload to Supabase immediately
      const supabaseUrl = await uploadStepImageToSupabase(aiProviderUrl, 'enhanced-upscale', executionId);
      currentImageUrl = aiProviderUrl;  // Use AI provider URL for next step
      
      const stepResult: PipelineStepResult = {
        stepType: 'enhanced-upscale',
        status: 'completed',
        imageUrl: supabaseUrl,  // Store Supabase URL in metadata
        originalUrl: aiProviderUrl,  // FAL.AI URL for next step
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for real-time update (4K is ready!)
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
    } catch (error) {
      console.warn('âš ï¸  Enhanced upscale failed, continuing with current image:', error);
      const stepResult: PipelineStepResult = {
        stepType: 'enhanced-upscale',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for failures too
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
      // Continue with previous image
    }
  }

  // Step 4: Face Swap (Professional/Enterprise only)
  if (enabledSteps.includes('replicate-face-swap') && currentImageUrl) {
    const startTime = Date.now();
    try {
      console.log('ğŸ”„ Starting Face Swap step...');
      console.log(`   Input: ${currentImageUrl.substring(0, 80)}...`);
      
      const faceSwapResult = await executeFaceSwap(modelImageUrl, currentImageUrl);
      const aiProviderUrl = faceSwapResult.output;
      
      // Upload to Supabase immediately
      const supabaseUrl = await uploadStepImageToSupabase(aiProviderUrl, 'replicate-face-swap', executionId);
      currentImageUrl = aiProviderUrl;  // Update for final result
      
      console.log(`âœ… Face Swap completed successfully`);
      console.log(`   Output: ${aiProviderUrl.substring(0, 80)}...`);
      
      const stepResult: PipelineStepResult = {
        stepType: 'replicate-face-swap',
        status: 'completed',
        imageUrl: supabaseUrl,  // Store Supabase URL in metadata
        originalUrl: aiProviderUrl,  // Keep Replicate URL
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for real-time update (Face swap is ready!)
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
    } catch (error) {
      console.warn('âš ï¸  Face swap failed, continuing with current image:', error);
      const stepResult: PipelineStepResult = {
        stepType: 'replicate-face-swap',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      };
      
      results.push(stepResult);
      
      // NEW: Call callback for failures too
      if (config.onStepComplete) {
        await config.onStepComplete(stepResult);
      }
      // Continue with previous image
    }
  }

  console.log('âœ… Pipeline execution completed', {
    totalSteps: results.length,
    successfulSteps: results.filter(r => r.status === 'completed').length,
    finalImageUrl: currentImageUrl,
  });

  return results;
}
