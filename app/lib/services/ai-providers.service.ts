/**
 * AI Provider Service
 * Handles integration with FAL AI and Replicate for image generation pipeline
 */

import { fal } from "@fal-ai/client";
import Replicate from "replicate";

// =============================================
// TYPES
// =============================================

export interface TryOnResult {
  image_url: string;
  seed?: number;
  has_nsfw_concepts?: boolean;
}

export interface UpscaleResult {
  image_url: string;
}

export interface FaceSwapResult {
  output: string; // Replicate returns single URL
}

export type QualityLevel = 'standard' | 'high' | 'premium';
export type PipelineStep = 'tryon' | 'basic-upscale' | 'enhanced-upscale' | 'replicate-face-swap';

// =============================================
// CONFIGURATION
// =============================================

const FAL_API_KEY = process.env.FAL_KEY;
const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;

// Initialize FAL AI client
if (!FAL_API_KEY) {
  console.error('❌ CRITICAL: FAL_KEY environment variable is not set!');
  console.error('Please check your .env file in the trayve-app directory');
} else {
  // Log the key format (first 10 chars only for security)
  const keyPreview = FAL_API_KEY.substring(0, 10) + '...';
  console.log('🔑 FAL_KEY found:', keyPreview);
  console.log('🔑 FAL_KEY length:', FAL_API_KEY.length);
  console.log('🔑 FAL_KEY format check:', FAL_API_KEY.includes(':') ? 'Contains colon ✓' : 'Missing colon ✗');
  
  // Configure FAL client with credentials
  fal.config({
    credentials: FAL_API_KEY,
  });
  console.log('✅ FAL AI client configured');
}

// Initialize Replicate client
let replicate: Replicate | null = null;
if (!REPLICATE_API_TOKEN) {
  console.warn('⚠️  REPLICATE_API_TOKEN environment variable is not set');
} else {
  replicate = new Replicate({
    auth: REPLICATE_API_TOKEN,
  });
  console.log('✅ Replicate client configured');
}

// =============================================
// FAL AI CLIENT
// =============================================

/**
 * Execute try-on generation using FAL AI Fashion Try-On
 * @param modelImageUrl - URL of the model/pose image
 * @param clothingImageUrl - URL of the clothing item
 * @param quality - Quality level for generation
 */
export async function executeTryOn(
  modelImageUrl: string,
  clothingImageUrl: string,
  quality: QualityLevel = 'standard'
): Promise<TryOnResult> {
  if (!FAL_API_KEY) {
    throw new Error('FAL AI API key is not configured');
  }

  try {
    console.log('🎨 Starting try-on generation with FAL AI Fashion Try-On...', {
      model: modelImageUrl.substring(0, 80) + '...',
      clothing: clothingImageUrl.substring(0, 80) + '...',
      quality,
    });

    // Use Fashion Try-On model for virtual try-on
    // This is the same model configuration that works in your main project
    const result = await fal.subscribe('easel-ai/fashion-tryon', {
      input: {
        full_body_image: modelImageUrl as any,
        clothing_image: clothingImageUrl as any,
        gender: "female" as any,
      },
      logs: true,
      onQueueUpdate: (update: any) => {
        if (update.status === 'IN_PROGRESS') {
          console.log(`💫 Try-on generation progress: ${update.status}`);
        }
      },
    });

    console.log('✅ Try-on generation completed successfully');

    // Extract image URL from result
    const imageUrl = result.data?.image?.url;
    
    if (!imageUrl) {
      console.error('❌ No image URL in result:', result);
      throw new Error('No image generated by FAL AI Fashion Try-On');
    }

    console.log('📸 Generated image URL:', imageUrl.substring(0, 100) + '...');

    return {
      image_url: imageUrl,
      has_nsfw_concepts: false,
    };
  } catch (error) {
    console.error('❌ FAL AI try-on error:', error);
    
    // Log detailed error information for debugging
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log validation errors from FAL AI
    if ((error as any).body?.detail) {
      console.error('🔍 Validation details:', JSON.stringify((error as any).body.detail, null, 2));
    }
    
    throw error;
  }
}

/**
 * Execute basic upscale using Replicate CodeFormer
 * @param imageUrl - URL of the image to upscale
 */
export async function executeBasicUpscale(imageUrl: string): Promise<UpscaleResult> {
  if (!REPLICATE_API_TOKEN) {
    throw new Error('Replicate API token is not configured');
  }

  try {
    console.log('📈 Starting basic upscale (2K) with Replicate CodeFormer...');
    console.log('🖼️  Input image:', imageUrl.substring(0, 100) + '...');
    
    const startTime = Date.now();

    // Use CodeFormer for face upsampling and enhancement (Replicate)
    const version = "cc4956dd26fa5a7185d5660cc9100fab1b8070a1d1654a8bb5eb6d443b020bb2";
    
    const response = await fetch("https://api.replicate.com/v1/predictions", {
      method: "POST",
      headers: {
        "Authorization": `Token ${REPLICATE_API_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        version,
        input: {
          image: imageUrl,
          codeformer_fidelity: 0.7,
          background_enhance: false,
          face_upsample: true,
          upscale: 2,
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Replicate API error: ${response.status} ${response.statusText}`);
    }

    let prediction = await response.json();
    const predictionId = prediction.id;
    
    console.log(`🔄 Basic upscale queued, prediction ID: ${predictionId}`);

    // Poll for completion
    while (prediction.status === 'starting' || prediction.status === 'processing') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const statusResponse = await fetch(`https://api.replicate.com/v1/predictions/${predictionId}`, {
        headers: {
          "Authorization": `Token ${REPLICATE_API_TOKEN}`,
        },
      });
      
      prediction = await statusResponse.json();
      
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(`⏳ Basic upscale in progress... (${elapsed}s elapsed, status: ${prediction.status})`);
    }

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    
    if (prediction.status !== 'succeeded') {
      throw new Error(`CodeFormer prediction failed with status: ${prediction.status}`);
    }

    console.log(`✅ Basic upscale completed in ${totalTime}s`);

    // Extract image URL from result
    const upscaledUrl = prediction.output;
    
    if (!upscaledUrl) {
      console.error('❌ No upscaled image in response:', JSON.stringify(prediction, null, 2));
      throw new Error('No upscaled image generated by Replicate CodeFormer');
    }

    console.log('📸 Upscaled image URL:', upscaledUrl.substring(0, 100) + '...');

    return {
      image_url: upscaledUrl,
    };
  } catch (error) {
    console.error('❌ Replicate CodeFormer basic upscale error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    throw error;
  }
}

/**
 * Execute enhanced upscale using FAL AI Recraft V3 Creative Upscaler
 * @param imageUrl - URL of the image to upscale
 */
export async function executeEnhancedUpscale(imageUrl: string): Promise<UpscaleResult> {
  if (!FAL_API_KEY) {
    throw new Error('FAL AI API key is not configured');
  }

  console.log('═══════════════════════════════════════════════════════');
  console.log('🔍 ENHANCED UPSCALE (4K) - START');
  console.log('═══════════════════════════════════════════════════════');
  console.log('📷 Input image URL:', imageUrl.substring(0, 100) + '...');
  console.log('🤖 Model: FAL AI Recraft V3 Creative Upscale');
  console.log('📐 Upscaling: Creative enhancement');

  try {
    const startTime = Date.now();

    // Use Recraft V3 Creative Upscaler for 4K enhancement
    const result = await fal.subscribe('fal-ai/recraft/upscale/creative', {
      input: {
        image_url: imageUrl,
        sync_mode: true,
        enable_safety_checker: false,
      },
      logs: true,
      onQueueUpdate: (update: any) => {
        if (update.status === 'IN_PROGRESS') {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          console.log(`⏳ Enhanced upscale in progress... (${elapsed}s elapsed)`);
        } else if (update.status === 'IN_QUEUE') {
          console.log(`🔄 Enhanced upscale queued, position: ${update.queue_position || 'unknown'}`);
        }
      },
    });

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`✅ Enhanced upscale processing completed in ${totalTime}s`);

    // Extract image URL from result
    const upscaledUrl = result.data?.image?.url;
    
    if (!upscaledUrl) {
      console.error('❌ No upscaled image in response:', JSON.stringify(result.data, null, 2));
      throw new Error('No enhanced upscaled image generated by FAL AI Recraft V3');
    }

    console.log('📸 Enhanced upscaled image URL:', upscaledUrl.substring(0, 100) + '...');
    console.log('═══════════════════════════════════════════════════════');
    console.log('✅ ENHANCED UPSCALE (4K) - COMPLETE');
    console.log(`⏱️  Total time: ${totalTime}s`);
    console.log('═══════════════════════════════════════════════════════');

    return {
      image_url: upscaledUrl,
    };
  } catch (error) {
    console.log('═══════════════════════════════════════════════════════');
    console.log('❌ ENHANCED UPSCALE (4K) - FAILED');
    console.log('═══════════════════════════════════════════════════════');
    console.error('❌ FAL AI enhanced upscale error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log FAL AI specific errors
    if ((error as any).body) {
      console.error('FAL AI error body:', JSON.stringify((error as any).body, null, 2));
    }
    
    if ((error as any).status) {
      console.error('FAL AI error status:', (error as any).status);
    }
    
    throw error;
  }
}

// =============================================
// REPLICATE CLIENT
// =============================================

/**
 * Execute face swap using Replicate Trayve Custom Model
 * @param sourceImageUrl - URL of the model image (face to extract FROM)
 * @param targetImageUrl - URL of the generated image (apply face TO)
 */
export async function executeFaceSwap(
  sourceImageUrl: string,
  targetImageUrl: string
): Promise<FaceSwapResult> {
  if (!replicate) {
    throw new Error('Replicate API token is not configured');
  }

  console.log('═══════════════════════════════════════════════════════');
  console.log('👤 FACE SWAP - START');
  console.log('═══════════════════════════════════════════════════════');
  console.log('📸 Source image (face FROM):', sourceImageUrl.substring(0, 80) + '...');
  console.log('🎯 Target image (apply TO):', targetImageUrl.substring(0, 80) + '...');
  console.log('🤖 Model: Replicate Trayve Custom Model');

  try {
    const startTime = Date.now();

    // Use Trayve custom face swap model (matches working main app)
    // Model: trayve-us/swap-model with specific version hash
    const modelVersion = "trayve-us/swap-model:7c647d4895ea2d5ff80ff3374709e3b35fa6ae070920f2ecf5d0c118b1a4a0f2";
    console.log('🚀 Submitting to Replicate API...');
    
    const output = await replicate.run(
      modelVersion as any,
      {
        input: {
          source_image: sourceImageUrl,  // Face to extract FROM
          target_image: targetImageUrl,  // Image to apply face TO
        }
      }
    );

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`✅ Face swap API call completed in ${totalTime}s`);
    console.log(`🔍 Output type: ${typeof output}`);
    console.log(`🔍 Output value:`, output);

    // Handle multiple output formats from Replicate
    let resultUrl: string;
    
    if (typeof output === 'string') {
      // Direct string URL (expected format)
      resultUrl = output;
      console.log('✅ Output is direct string URL');
    } else if (Array.isArray(output) && output.length > 0) {
      // Array of URLs - take first one
      resultUrl = output[0];
      console.log(`✅ Output is array, using first element: ${resultUrl.substring(0, 80)}...`);
    } else if (output && typeof output === 'object') {
      // Object with url property or ReadableStream
      if ('url' in output && typeof (output as any).url === 'string') {
        resultUrl = (output as any).url;
        console.log(`✅ Extracted URL from object.url property`);
      } else {
        // ReadableStream or other object - convert to string and hope for URL
        console.warn('⚠️  Unexpected output format, attempting string conversion');
        resultUrl = String(output);
      }
    } else {
      console.error('❌ Invalid face swap output type:', typeof output);
      console.error('❌ Output value:', output);
      throw new Error(`Unexpected output format from Replicate: ${typeof output}`);
    }

    // Validate the result is a valid URL string
    if (!resultUrl || typeof resultUrl !== 'string' || resultUrl.length === 0) {
      console.error('❌ Result URL is empty or invalid:', resultUrl);
      throw new Error('Face swap did not return a valid image URL');
    }

    console.log('📸 Face swap result URL:', resultUrl.substring(0, 100) + '...');
    console.log('═══════════════════════════════════════════════════════');
    console.log('✅ FACE SWAP - COMPLETE');
    console.log(`⏱️  Total time: ${totalTime}s`);
    console.log('═══════════════════════════════════════════════════════');

    return {
      output: resultUrl,
    };
  } catch (error) {
    console.log('═══════════════════════════════════════════════════════');
    console.log('❌ FACE SWAP - FAILED');
    console.log('═══════════════════════════════════════════════════════');
    console.error('❌ Replicate face swap error:', error);
    
    // Log detailed error information
    if (error instanceof Error) {
      console.error('Error name:', error.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    
    // Log Replicate specific errors
    if ((error as any).response) {
      console.error('Replicate error response:', JSON.stringify((error as any).response, null, 2));
    }
    
    if ((error as any).status) {
      console.error('Replicate error status:', (error as any).status);
    }
    
    throw error;
  }
}

// =============================================
// TIER-BASED STEP CONFIGURATION
// =============================================

/**
 * Get enabled steps for a subscription tier
 */
export function getEnabledSteps(tier: string): PipelineStep[] {
  const tierSteps: Record<string, PipelineStep[]> = {
    free: ['tryon', 'basic-upscale'],
    starter: ['tryon', 'basic-upscale'],
    creator: ['tryon', 'basic-upscale'],
    professional: ['tryon', 'enhanced-upscale', 'replicate-face-swap'],
    enterprise: ['tryon', 'enhanced-upscale', 'replicate-face-swap'],
  };

  return tierSteps[tier] || tierSteps.free;
}

/**
 * Get quality level for a subscription tier
 */
export function getQualityLevel(tier: string): QualityLevel {
  const tierQuality: Record<string, QualityLevel> = {
    free: 'standard',
    starter: 'standard',
    creator: 'high',
    professional: 'premium',
    enterprise: 'premium',
  };

  return tierQuality[tier] || 'standard';
}

// =============================================
// PIPELINE EXECUTOR
// =============================================

export interface PipelineConfig {
  tier: string;
  enabledSteps?: PipelineStep[];
  quality?: QualityLevel;
}

export interface PipelineStepResult {
  stepType: PipelineStep;
  status: 'completed' | 'failed' | 'skipped';
  imageUrl?: string;  // Final stored URL (Supabase)
  originalUrl?: string;  // Original FAL.AI/Replicate URL (for next steps, bypasses 5MB limit)
  error?: string;
  processingTime?: number;
}

/**
 * Execute full pipeline with tier-based steps
 * @param modelImageUrl - URL of the model/pose image
 * @param clothingImageUrl - URL of the clothing item
 * @param config - Pipeline configuration
 */
export async function executePipeline(
  modelImageUrl: string,
  clothingImageUrl: string,
  config: PipelineConfig
): Promise<PipelineStepResult[]> {
  const enabledSteps = config.enabledSteps || getEnabledSteps(config.tier);
  const quality = config.quality || getQualityLevel(config.tier);
  
  const results: PipelineStepResult[] = [];
  let currentImageUrl = '';

  console.log('🚀 Starting pipeline execution...', {
    tier: config.tier,
    steps: enabledSteps,
    quality,
  });

  // Step 1: Try-On (Required)
  if (enabledSteps.includes('tryon')) {
    const startTime = Date.now();
    try {
      const tryOnResult = await executeTryOn(modelImageUrl, clothingImageUrl, quality);
      currentImageUrl = tryOnResult.image_url;
      
      results.push({
        stepType: 'tryon',
        status: 'completed',
        imageUrl: currentImageUrl,
        originalUrl: currentImageUrl,  // FAL.AI URL (stays <5MB)
        processingTime: Date.now() - startTime,
      });
    } catch (error) {
      results.push({
        stepType: 'tryon',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      });
      
      // If try-on fails, entire pipeline fails
      throw error;
    }
  }

  // Step 2: Basic Upscale
  if (enabledSteps.includes('basic-upscale') && currentImageUrl) {
    const startTime = Date.now();
    try {
      const upscaleResult = await executeBasicUpscale(currentImageUrl);
      const originalUrl = upscaleResult.image_url;  // Replicate URL
      currentImageUrl = originalUrl;
      
      results.push({
        stepType: 'basic-upscale',
        status: 'completed',
        imageUrl: currentImageUrl,
        originalUrl: originalUrl,  // Keep Replicate URL for next step
        processingTime: Date.now() - startTime,
      });
    } catch (error) {
      console.warn('⚠️  Basic upscale failed, continuing with original image:', error);
      results.push({
        stepType: 'basic-upscale',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      });
      // Continue with previous image
    }
  }

  // Step 3: Enhanced Upscale (Professional/Enterprise only)
  if (enabledSteps.includes('enhanced-upscale') && currentImageUrl) {
    const startTime = Date.now();
    try {
      // Use originalUrl from previous step to bypass 5MB limit
      const previousStep = results[results.length - 1];
      const inputUrl = previousStep?.originalUrl || currentImageUrl;
      
      console.log(`📥 Enhanced upscale input: ${inputUrl.substring(0, 80)}...`);
      const enhancedResult = await executeEnhancedUpscale(inputUrl);
      currentImageUrl = enhancedResult.image_url;
      
      results.push({
        stepType: 'enhanced-upscale',
        status: 'completed',
        imageUrl: currentImageUrl,
        originalUrl: currentImageUrl,  // FAL.AI URL
        processingTime: Date.now() - startTime,
      });
    } catch (error) {
      console.warn('⚠️  Enhanced upscale failed, continuing with current image:', error);
      results.push({
        stepType: 'enhanced-upscale',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      });
      // Continue with previous image
    }
  }

  // Step 4: Face Swap (Professional/Enterprise only)
  if (enabledSteps.includes('replicate-face-swap') && currentImageUrl) {
    const startTime = Date.now();
    try {
      console.log('🔄 Starting Face Swap step...');
      console.log(`   Input: ${currentImageUrl.substring(0, 80)}...`);
      
      const faceSwapResult = await executeFaceSwap(modelImageUrl, currentImageUrl);
      currentImageUrl = faceSwapResult.output;
      
      console.log(`✅ Face Swap completed successfully`);
      console.log(`   Output: ${currentImageUrl.substring(0, 80)}...`);
      
      results.push({
        stepType: 'replicate-face-swap',
        status: 'completed',
        imageUrl: currentImageUrl,
        processingTime: Date.now() - startTime,
      });
    } catch (error) {
      console.warn('⚠️  Face swap failed, continuing with current image:', error);
      results.push({
        stepType: 'replicate-face-swap',
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime: Date.now() - startTime,
      });
      // Continue with previous image
    }
  }

  console.log('✅ Pipeline execution completed', {
    totalSteps: results.length,
    successfulSteps: results.filter(r => r.status === 'completed').length,
    finalImageUrl: currentImageUrl,
  });

  return results;
}
